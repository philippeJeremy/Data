Partie 1:

Nous avons vu deux types d‚Äô√©l√©ments : des clauses (vous commencez √† en conna√Ætre un certain nombre) et des fonctions (cette fois-ci c‚Äôest nouveau). Leur nature est bien diff√©rente, et ne doit pas √™tre confondue.

La clause est un ordre √† la machine (trie moi dans tel ordre, s√©lectionne moi dans cette table)

La fonction est la r√©sultante de la transformation d‚Äôune ou de plusieurs variables, c‚Äôest donc une variable, ou une m√©trique (max(x) est une nouvelle valeur)

Les fonctions d‚Äôagr√©gation permettent de renvoyer une seule valeur, rendant possible une analyse de vos donn√©es en pr√©sence.

COUNT(.) est une fonction qui compte le nombre de lignes non vides pour une colonne donn√©e. COUNT(*) comptabilise chaque ligne qui n‚Äôest pas int√©gralement vide.

GROUP BY est une clause qui structure vos r√©sultats en fonction des modalit√©s d‚Äôune variable cat√©gorielle. Vos fonctions d‚Äôagr√©gation s‚Äôappliqueront alors √† chacun des sous-groupes cr√©√©s. GROUP BY genre permet par exemple de restituer une ligne par genre diff√©rent dans la base.

SUM(.) , MAX(.) et MIN(.) renvoient respectivement la somme, le maximum et le minimum relatifs √† une variable. Ces variables doivent √™tre des nombre pour que la machine puisse les trier proprement.

AVG(.) vous renvoie la moyenne arithm√©tique d‚Äôune variable. Par d√©faut, la machine vous renverra la moyenne la plus pr√©cise possible.

ROUND( . , . ) permet de pallier √† ce probl√®me. Le premier argument est la variable √† arrondir, et le second le nombre de d√©cimales que l‚Äôon souhaite. ROUND n‚Äôest pas une fonction d‚Äôagr√©gation, elle restitue autant d‚Äô√©l√©ments que la variable d‚Äôentr√©e.
HAVING est la clause qui est √† GROUP BY ce que WHERE est √† SELECT FROM. Elle permet d‚Äô√©mettre une condition venant sortir les groupes qui ne nous int√©ressent pas.

Enfin d‚Äôordre d‚Äôex√©cution compte pour s‚Äô√©viter des probl√®me de compilation. Il est le suivant :

SELECT column1, AVG(column2) AS new_name
FROM mytable
   WHERE condition1 AND condition2
   GROUP BY column
   HAVING condition3 OR condition4
   ORDER BY column1 DESC
   LIMIT 12;
Partie 2:

Nous avons appris √† extraire des dates, faire des jointures gr√¢ce aux cl√© primaires et secondaires, effectuer des sous-requ√™tes, et stocker nos sous requ√™tes.

EXTRACT (year/month/day FROM date) nous permet d‚Äôextraire uniquement le champ qui nous int√©resse dans une date. Un alias (AS) permettra d‚Äôappeler cette nouvelle variable par la suite.

Cl√©s primaires permettent de servir d‚Äôindex de la table √† laquelle est appartiennent. (ID)

Cl√©s secondaires (ou √©trang√®res) servent d‚Äôindex, relativement √† une table √† laquelle elles n‚Äôappartiennent pas. Cela est particuli√®rement utile pour une jointure entre deux tables ne poss√©dant pas la m√™me granularit√© (ie unit√© de mesure ligne par ligne).

Les jointures dans SQL sont des clauses qui vous permettent de combiner les lignes plusieurs tables en m√™me temps.

INNER JOIN (ou JOIN) permet de r√©aliser une jointure en ne conservant que l‚Äôintersection de nos deux tables, c‚Äôest √† dire uniquement les lignes pour lesquelles les cl√©s de jointure co√Øncident. La syntaxe est la suivante :

SELECT variable1, variable2 FROM Base1.Table1 AS Table1
INNER JOIN Base2.Table2 ASTable2 ON Table2.cl√© = Table1.cl√© ;
Les alias de tables sont essentiels pour r√©aliser de bonnes jointures, pour pouvoir expliciter ensuite la source de chaque cl√©.

OUTER JOIN va aussi inclure les ID qui ne matchent pas dans la table que vous souhaitez. La syntaxe est alors :

SELECT variable1, variable2 FROM Base1.Table1 AS Table1
FULL OUTER JOIN Base2.Table2 ASTable2 ON Table2.cl√© = Table1.cl√©;
LEFT JOIN et RIGHT JOIN permettent de conserver les informations qui ne matchent pas, mais uniquement dans une des deux tables (celle apr√®s FROM pour LEFT, celle apr√®s JOIN pour RIGHT). LEFT JOIN reste de loin la plus usuelle (et intuitive).
Il est tout √† fait possible de r√©aliser plusieurs jointures en appelant la clause successivement.

La commande USING (variable) permet de donner en une seule fois la cl√© de jointure, √† condition que son nom soit strictement le m√™me dans chacune des tables.

Les requ√™tes peuvent √™tre imbriqu√©es entre elles, afin de donner plus d‚Äô√©paisseur √† votre requ√™te globale. Des parenth√®ses viennent indiquer le d√©but et la fin de la sous-requ√™te :

SELECT variable FROM Base.Table
WHERE variable > (SELECT AVG (variable) FROM Base.Table);
Enfin la clause WITH AS permet de d√©finir en amont nos sous-requ√™te, et de leur attribuer un nom (un peu comme une fonction), afin de pouvoir les appeler tr√®s facilement ensuite. Plus vous pratiquerez SQL et complexifierez vos requ√™tes, plus vous vous rendrez compte de l‚Äôint√©r√™t de cette clause.
WITH sous_requete1 AS (
SELECT variable1 FROM Base.Table
WHERE condition)
SELECT SUM (variable1) FROM sous_requete1;
Voil√† ! On commence √† entrer dans la partie un peu plus difficile de ce bootcamp, donc ne vous d√©moralisez pas si vous ne comprenez pas de mani√®re aussi intuitive qu‚Äôau d√©but.

La cl√© d‚Äôune bonne compr√©hension en programmation, c‚Äôest la pratique (malgr√© ses moments de frustration) ! Enfin je suis √† disposition pour vous aider √† comprendre, posez-moi vos questions! :visage_l√©g√®rement_souriant:

Aussi, si vous pouviez donner votre retour sur ce module sur le lien suivant ce serait top! https://share.hsforms.com/1F82wa50-THmDDMxHdik-HQ2jjd7
FYI, les corrig√©s des exercices sont d√©sormais dans le drive. Bravo √† tous pour les avoir trait√© avec brio! üí™